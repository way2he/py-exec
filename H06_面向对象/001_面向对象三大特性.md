# Python面向对象-三大特性

## 一、基本概念
面向对象编程（OOP）是Python的核心编程范式之一，通过类（Class）和对象（Object）实现数据封装、继承和多态。三大核心特性为：封装（Encapsulation）、继承（Inheritance）、多态（Polymorphism）。

- 面向对象编程（Object-Oriented Programming, OOP）是一种以「对象」为核心的编程范式，通过将现实世界中的事物抽象为「类」（Class），再基于类创建具体「对象」（Object），实现数据（属性）与操作（方法）的统一管理。其核心是模拟真实世界的事物关系，提升代码的可复用性、可维护性和扩展性。
- 封装是基础（保护数据），继承是扩展（复用代码），多态是灵魂（灵活调用）。

### 1.1 封装
将数据（属性）和操作数据的行为（方法）绑定在一起，通过访问控制（公有/私有）隐藏内部实现细节。

### 1.2 继承
子类（派生类）继承父类（基类）的属性和方法，支持代码复用和扩展。

### 1.3 多态
不同子类对同一方法的不同实现，提高代码灵活性和可维护性。

## 二、示例代码
### 2.1 封装示例
```python
class Person:  # 定义人类
    def __init__(self, name, age):
        self._name = name  # 单下划线表示受保护属性
        self.__age = age   # 双下划线表示私有属性

    def get_age(self):
        return self.__age  # 公有方法访问私有属性

    def set_age(self, new_age):
        if new_age > 0:
            self.__age = new_age  # 公有方法修改私有属性

# 使用示例
p = Person("张三", 20)
p.set_age(21)
print(p._name, p.get_age())  # 输出：张三 21
```

### 2.2 继承示例
```python
class Animal:  # 基类
    def __init__(self, name):
        self.name = name

    def speak(self):
        raise NotImplementedError("子类必须实现speak方法")

class Dog(Animal):  # 子类继承Animal
    def speak(self):
        return "汪汪"

class Cat(Animal):  # 子类继承Animal
    def speak(self):
        return "喵喵"

# 使用示例
dog = Dog("小白")
cat = Cat("小花")
print(dog.speak(), cat.speak())  # 输出：汪汪 喵喵
```

### 2.3 多态示例
```python
def animal_speak(animal):
    print(animal.speak())  # 调用不同子类的speak方法

animal_speak(Dog("小白"))  # 输出：汪汪
animal_speak(Cat("小花"))  # 输出：喵喵
```

## 三、适用场景
### 3.1 封装
- 需要隐藏内部状态（如用户密码、设备参数）
- 提供统一接口（如数据库连接类）

### 3.2 继承
- 多层级分类系统（如生物分类、权限系统）
- 框架扩展（如Django的Model类）

### 3.3 多态
- 事件处理（如不同按钮点击事件）
- 插件系统（如日志处理器的不同实现）

## 四、常见陷阱与规避
### 4.1 封装陷阱
- 错误使用双下划线（`__attr`）导致名称改写（Name Mangling）
  - 规避：使用单下划线（`_attr`）表示受保护属性，明确文档说明
- 过度封装（所有属性都设为私有）
  - 规避：根据业务需求保留必要的公有属性

### 4.2 继承陷阱
- 菱形继承（多继承导致方法冲突）
  - 规避：使用`super()`按MRO顺序调用（Python3默认C3线性化算法）
      [C3线性化算法详解](https://en.wikipedia.org/wiki/C3_linearization):
      C3线性化算法是Python 3中用于确定多继承类的方法解析顺序（MRO, Method Resolution Order）的核心算法。其设计目标是解决传统深度优先算法在菱形继承场景下的缺陷（如子类无法覆盖祖先类方法），确保继承顺序满足 局部优先级 和 单调性 原则
      ```
        class A: pass
        class B(A): pass
        class C(A): pass
        class D(B, C): pass  # 多继承B和C
      ```
      传统深度优先算法：
      ```
        D -> B -> A -> C -> A
      ```
      C3线性化算法：
      ```
        D -> B -> C -> A
      ```
      这样可以保证子类优先继承最近的祖先类，避免方法冲突。
- 父类方法修改影响所有子类
  - 规避：通过单元测试覆盖所有子类

### 4.3 多态陷阱
- 子类未实现基类抽象方法
  - 规避：使用`abc`模块定义抽象基类（Abstract Base Class）
```python
from abc import ABC, abstractmethod

class Animal(ABC):  # 抽象基类
    @abstractmethod
    def speak(self):
        pass

class Dog(Animal):  # 必须实现speak方法，否则无法实例化
    def speak(self):
        return "汪汪"
```

## 五、核心语法与执行流程
### 5.1 类定义
```python
class ClassName(BaseClass):  # 继承基类
    class_var = 0  # 类变量

    def __init__(self, param):  # 构造方法
        self.instance_var = param  # 实例变量

    def instance_method(self):  # 实例方法
        pass

    @classmethod
    def class_method(cls):  # 类方法
        pass

    @staticmethod
    def static_method():  # 静态方法
        pass
```

### 5.2 方法查找流程（MRO）
Python通过`__mro__`属性显示方法解析顺序（Method Resolution Order）：
```python
print(Dog.__mro__)
# 输出：(<class '__main__.Dog'>, <class '__main__.Animal'>, <class 'object'>)
```

## 六、最佳实践
1. **单一职责原则**：一个类只负责一项功能
2. **里氏替换原则**：子类可替代父类且行为一致
3. **组合优于继承**：通过`has-a`关系替代`is-a`关系减少耦合
```python
class Car:
    def __init__(self, engine):
        self.engine = engine  # 组合引擎对象

class GasEngine:
    def start(self):
        print("燃油引擎启动")

class ElectricEngine:
    def start(self):
        print("电动引擎启动")

car1 = Car(GasEngine())
car2 = Car(ElectricEngine())
car1.engine.start()  # 输出：燃油引擎启动
car2.engine.start()  # 输出：电动引擎启动
```

## 七、性能优化
1. **实例变量预分配**：使用`__slots__`减少内存占用（适用于大量实例场景）
```python
class Person:
    __slots__ = ('name', 'age')  # 限制实例属性
    def __init__(self, name, age):
        self.name = name
        self.age = age
```
2. **缓存常用方法**：使用`lru_cache`装饰器缓存重复计算（需注意不可变参数）

   - **核心作用**：`lru_cache`是Python标准库`functools`中的装饰器，通过缓存函数返回值避免重复计算，显著提升递归、数学计算等场景的性能。
   - **LRU策略**：缓存容量（`maxsize`）耗尽时移除最久未使用的缓存项，平衡性能与内存。
   - **不可变参数要求**：因缓存键基于参数哈希值生成，参数需为不可变类型（如元组、字符串），可变类型（如列表）会导致`TypeError`。
   - **示例**：
     ```python
     from functools import lru_cache
     
     @lru_cache(maxsize=128)  # 限制最大缓存128项
     def fib(n):
         if n < 2: return n
         return fib(n-1) + fib(n-2)
     
     print(fib(30))  # 首次计算后结果被缓存，后续调用直接返回
     ```

## 八、使用建议
- 优先使用`dataclass`简化数据类（Python3.7+）

   - **核心作用**：`dataclass`是Python 3.7+引入的装饰器，通过自动生成`__init__`、`__repr__`、`__eq__`等方法，大幅减少数据类的样板代码。
   - **基本用法**：用`@dataclass`装饰类，只需定义字段及类型（支持类型注解），可选字段可设置默认值。
   - **示例**：
     ```python
     from dataclasses import dataclass
     
     @dataclass
     class Book:
         title: str
         price: float
         author: str = "未知"
     
     book = Book("Python编程", 99.9)
     print(book)  # 输出：Book(title='Python编程', price=99.9, author='未知')
     ```
   - **优势**：代码更简洁（减少约50%样板代码）、字段类型明确（提升可读性）、内置比较方法（直接`==`比较实例）。
```python
from dataclasses import dataclass

@dataclass
class User:
    name: str
    age: int
    def info(self):
        return f"{self.name}({self.age}岁)"

user = User("李四", 25)
print(user.info())  # 输出：李四(25岁)
```
- 避免深度继承（建议不超过3层）
- 为公共方法添加类型注解（提高可读性）

## 九、经验总结
面向对象三大特性是构建复杂系统的基石：
1. 封装保证数据安全，通过访问控制隔离实现细节
2. 继承实现代码复用，需谨慎处理多继承冲突
3. 多态提升代码扩展性，结合抽象基类可强制行为规范

实际开发中应根据业务场景选择特性组合，避免过度设计。建议从简单类开始，逐步抽象，通过单元测试验证类的行为一致性。

## 十、综合案例应用

```python
from abc import ABC, abstractmethod
from dataclasses import dataclass
from functools import lru_cache


# 1. 定义抽象基类（ABC + abstractmethod）
class Shape(ABC):
    @abstractmethod  # 强制子类实现面积计算方法
    def calculate_area(self) -> float:
        """抽象方法：计算图形面积"""
        pass

    def print_info(self) -> None:
        """公共方法：打印实例信息（演示self使用）"""
        print(f"当前图形类型：{self.__class__.__name__}，参数：{self.__dict__}")  # self引用实例属性


# 2. 定义具体图形类（使用dataclass简化代码）
@dataclass(frozen=True)  # frozen=True使实例不可变（满足lru_cache对不可变参数的要求）
class Circle(Shape):
    radius: float  # dataclass自动生成__init__和__repr__

    @lru_cache(maxsize=100)  # 缓存最近100次计算结果
    def calculate_area(self) -> float:
        """实现抽象方法：计算圆面积（演示lru_cache）"""
        print("执行圆面积计算（未命中缓存）")  # 验证缓存效果
        return 3.1416 * self.radius ** 2  # self引用实例属性radius


@dataclass(frozen=True)
class Rectangle(Shape):
    length: float
    width: float

    @lru_cache(maxsize=100)
    def calculate_area(self) -> float:
        """实现抽象方法：计算矩形面积"""
        print("执行矩形面积计算（未命中缓存）")
        return self.length * self.width  # self引用实例属性length/width


# 3. 测试案例
if __name__ == "__main__":
    # 创建实例（dataclass简化初始化）
    circle = Circle(radius=5)
    rectangle = Rectangle(length=4, width=6)

    # 调用公共方法（self演示）
    circle.print_info()  # 输出：当前图形类型：Circle，参数：{'radius': 5}
    rectangle.print_info()  # 输出：当前图形类型：Rectangle，参数：{'length': 4, 'width': 6}

    # 调用面积计算（lru_cache演示）
    print("第一次计算圆面积：", circle.calculate_area())  # 输出计算过程+结果
    print("第二次计算圆面积：", circle.calculate_area())  # 直接从缓存获取，无计算过程

    print("第一次计算矩形面积：", rectangle.calculate_area())  # 输出计算过程+结果
    print("第二次计算矩形面积：", rectangle.calculate_area())  # 直接从缓存获取


```
### 关键技术点说明
1. ABC与abstractmethod ： `Shape` 作为抽象基类，通过 @abstractmethod 强制子类实现 `calculate_area` 方法，确保所有图形类都具备面积计算能力。
2. dataclass ： `Circle` 和 `Rectangle` 使用 @dataclass(frozen=True) ，自动生成 __init__ / __repr__ 等方法，同时 frozen=True 保证实例不可变（满足 lru_cache 对参数哈希的要求）。
3. lru_cache ：在 `calculate_area` 方法上使用 @lru_cache ，对相同参数的重复调用直接返回缓存结果，避免重复计算（测试中第二次调用无计算过程输出）。
4. self ：在 `print_info` 方法和 `calculate_area` 方法中，通过 self 引用实例的 radius / length / width 属性，实现实例数据的访问。

```python
当前图形类型：Circle，参数：{'radius': 5}
当前图形类型：Rectangle，参数：{'length': 4, 'width': 6}
执行圆面积计算（未命中缓存）
第一次计算圆面积： 78.54
第二次计算圆面积： 78.54
执行矩形面积计算（未命中缓存）
第一次计算矩形面积： 24
第二次计算矩形面积： 24
```