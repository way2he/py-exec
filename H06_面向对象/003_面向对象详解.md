# Python面向对象核心机制详解：`__new__`、`__slots__`、`__init__`、`self`及装饰器家族

## 引言
面向对象编程（OOP）是Python的核心范式之一，其强大能力源于对类与对象机制的深度支持。本文将围绕`__new__`、`__slots__`、`__init__`、`self`、`@classmethod`、`@staticmethod`、`__str__`、`__repr__`、`@property`等核心成员展开，通过原理剖析、示例代码和最佳实践，帮助开发者建立系统化的面向对象知识体系。

---

## 一、类的生命周期：`__new__`与`__init__`的协同
### 1.1 `__new__`：对象创建的起点
`__new__`是类的静态方法（隐式），负责创建类的实例。它是类实例化过程中第一个被调用的方法，返回新创建的对象实例（或子类实例）。

**核心特性**：
- 第一个参数是类本身（`cls`），区别于`__init__`的`self`
- 必须返回一个类实例（通常通过`super().__new__(cls)`调用基类实现）
- 可用于实现单例模式、对象池等创建逻辑

**示例：自定义`__new__`实现类型校验**
```python
class IntOnly:    
    def __new__(cls, value):        
        # 校验输入是否为整数        
        if not isinstance(value, int):            
            raise TypeError("Value must be an integer")        
        # 调用基类__new__创建实例        
        instance = super().__new__(cls)        
        return instance    
    def __init__(self, value):        
        self.value = value

# 测试
try:    
    obj = IntOnly("123")  # 触发TypeError
except TypeError as e:    
    print(f"Error: {e}")  # 输出：Error: Value must be an integer
```

### 1.2 `__init__`：对象初始化的核心
`__init__`是实例方法，在`__new__`返回实例后被调用，负责完成对象的初始化（属性赋值、资源加载等）。

**关键区别**：
| 特征         | `__new__`                | `__init__`               |
|--------------|--------------------------|--------------------------|
| 调用时机     | 实例创建前               | 实例创建后               |
| 第一个参数   | 类（`cls`）              | 实例（`self`）           |
| 返回值       | 必须返回实例或`None`     | 无返回值（`None`）       |
| 主要职责     | 对象创建逻辑             | 对象初始化逻辑           |

**最佳实践**：避免在`__new__`中执行复杂初始化，保持`__new__`轻量级（仅处理创建逻辑），将业务初始化放在`__init__`。

---

## 二、内存优化利器：`__slots__`
### 2.1 内存占用的痛点
默认情况下，Python对象通过`__dict__`字典存储实例属性，这会带来额外的内存开销（字典本身的哈希表结构）。对于需要创建大量实例的场景（如游戏角色、数据模型），内存占用会显著增加。

### 2.2 `__slots__`的工作原理
通过在类中定义`__slots__`类变量（包含允许的属性名的元组），Python会：
- 禁用`__dict__`和`__weakref__`（除非显式包含）
- 使用固定大小的数组存储实例属性
- 限制动态添加属性（提高类型安全性）

**示例：对比`__slots__`的内存优化效果**
```python
import sys

class WithoutSlots:    
    def __init__(self, a, b, c):        
        self.a = a        
        self.b = b        
        self.c = c

class WithSlots:    
    __slots__ = ("a", "b", "c")  # 定义允许的属性    
    def __init__(self, a, b, c):        
        self.a = a        
        self.b = b        
        self.c = c

# 测试内存占用
obj1 = WithoutSlots(1, 2, 3)
obj2 = WithSlots(1, 2, 3)

print(f"Without slots: {sys.getsizeof(obj1)} bytes")  # 约80 bytes
print(f"With slots: {sys.getsizeof(obj2)} bytes")     # 约48 bytes
```

### 2.3 适用场景与陷阱
- **推荐场景**：需要创建大量实例的类（如ORM模型、数据传输对象）、对内存敏感的应用
- **常见陷阱**：
  - 子类若未定义`__slots__`，会继承父类的`__slots__`并添加自己的`__dict__`
  - 无法动态添加`__slots__`外的属性（除非在`__slots__`中包含`'__dict__'`）
  - 弱引用（`__weakref__`）需要显式包含在`__slots__`中

---

## 三、`self`的本质：实例的身份标识
### 3.1 `self`的底层逻辑
`self`是方法的第一个参数，指向调用该方法的实例对象。Python在调用实例方法时，会自动将实例作为第一个参数传递（即方法绑定机制）。

**示例：手动模拟方法绑定**
```python
class MyClass:    
    def method(self, x):        
        return self, x

obj = MyClass()
# 等价调用方式
print(obj.method(10))          # (<__main__.MyClass object at 0x...>, 10)
print(MyClass.method(obj, 10)) # 与上一行结果相同
```

### 3.2 避免的常见错误
- 忘记在方法定义中添加`self`参数（导致`TypeError`）
- 在类外部错误地将`self`作为普通变量使用
- 在`@staticmethod`中错误使用`self`（静态方法无实例绑定）

---

## 四、装饰器家族：`@classmethod`、`@staticmethod`与`@property`
### 4.1 `@classmethod`：类级别的多面手
`@classmethod`装饰的方法第一个参数是类本身（`cls`），可用于：
- 实现多构造函数（替代工厂函数）
- 操作类变量（如统计实例数量）
- 子类化时保留多态性

**示例：多构造函数实现**
```python
from datetime import datetime

class Date:    
    def __init__(self, year, month, day):        
        self.year = year        
        self.month = month        
        self.day = day    
    @classmethod    
    def from_string(cls, date_str):        
        # 解析"YYYY-MM-DD"格式字符串        
        year, month, day = map(int, date_str.split("-"))        
        return cls(year, month, day)    
    @classmethod    
    def today(cls):        
        # 获取当前日期        
        today = datetime.today()        
        return cls(today.year, today.month, today.day)

# 使用示例
date1 = Date.from_string("2023-10-01")
date2 = Date.today()
print(f"date1: {date1.year}-{date1.month}-{date1.day}")  # 输出：date1: 2023-10-01
print(f"date2: {date2.year}-{date2.month}-{date2.day}")  # 输出当前日期
```

### 4.2 `@staticmethod`：无绑定的工具方法
`@staticmethod`装饰的方法既不接收`self`也不接收`cls`，本质是类命名空间中的普通函数。适用于：
- 与类相关但不需要访问类/实例状态的工具方法
- 提高代码组织性（将函数归类到相关类下）

**示例：数学工具类**
```python
class MathUtils:    
    @staticmethod    
    def add(a, b):        
        return a + b    
    @staticmethod    
    def multiply(a, b):        
        return a * b

# 使用示例
print(MathUtils.add(2, 3))       # 输出：5
print(MathUtils.multiply(4, 5))  # 输出：20
```

### 4.3 `@property`：属性的访问控制
`@property`允许将方法伪装成实例属性，实现对属性的读取、设置和删除控制。

**核心组件**：
- `@property`：读操作装饰器（对应`__get__`）
- `@<name>.setter`：写操作装饰器（对应`__set__`）
- `@<name>.deleter`：删除操作装饰器（对应`__delete__`）

**示例：温度转换的属性控制**
```python
class Temperature:    
    def __init__(self, celsius):        
        self._celsius = celsius    
    @property    
    def celsius(self):        
        return self._celsius    
    @celsius.setter    
    def celsius(self, value):        
        if value < -273.15:            
            raise ValueError("Temperature below absolute zero")        
        self._celsius = value    
    @property    
    def fahrenheit(self):        
        return self._celsius * 9/5 + 32

# 使用示例
temp = Temperature(25)
print(temp.fahrenheit)  # 输出：77.0
temp.celsius = 100
print(temp.fahrenheit)  # 输出：212.0
temp.celsius = -300    # 触发ValueError
```

---

## 五、对象的字符串表示：`__str__`与`__repr__`
### 5.1 核心区别
| 方法       | 调用场景                  | 设计目标                  | 推荐格式                |
|------------|---------------------------|---------------------------|-------------------------|
| `__str__`  | `str(obj)`、`print(obj)`  | 面向用户的可读字符串      | 自然语言描述            |
| `__repr__` | `repr(obj)`、交互式环境   | 面向开发者的精确描述      | 可重建对象的代码字符串  |

### 5.2 最佳实践
- 始终实现`__repr__`（默认实现返回内存地址，无信息量）
- `__str__`可选，但建议实现以提供友好输出
- `__repr__`应满足`eval(repr(obj)) == obj`（理想情况）

**示例：完整实现双方法**
```python
class Point:    
    def __init__(self, x, y):        
        self.x = x        
        self.y = y    
    def __repr__(self):        
        return f"Point({self.x}, {self.y})"  # 可直接用于重建对象    
    def __str__(self):        
        return f"Point at ({self.x}, {self.y})"  # 更友好的描述

# 测试
p = Point(3, 4)
print(repr(p))  # 输出：Point(3, 4)
print(str(p))   # 输出：Point at (3, 4)
```

---

## 六、底层原理与源码分析
### 6.1 类实例化的完整流程
Python实例化对象时，解释器会执行以下步骤（以`obj = MyClass()`为例）：
1. 调用`MyClass.__new__(MyClass)`创建实例
2. 检查`__new__`返回值是否为`MyClass`或其子类的实例
3. 调用`MyClass.__init__(instance)`完成初始化
4. 返回初始化后的实例

### 6.2 `__slots__`的内存优化实现
通过查看CPython源码（`Objects/typeobject.c`中的`slots_init`函数），`__slots__`通过`PyMemberDef`结构体数组存储属性描述符，避免了`__dict__`的哈希表开销。每个实例的属性存储在连续内存块中，访问效率更高（类似C结构体）。

---

## 七、常见陷阱与规避
### 7.1 `__init__`返回非`None`值
`__init__`设计为无返回值，若返回非`None`会触发`TypeError`。
```python
class BadClass:    
    def __init__(self):        
        return 42  # 错误！

# 实例化时触发：TypeError: __init__() should return None, not 'int'
```

### 7.2 错误使用`self`在静态方法中
`@staticmethod`无`self`参数，直接引用会导致`NameError`。
```python
class WrongUsage:    
    @staticmethod    
    def method():        
        return self.value  # 错误：self未定义
```

### 7.3 `__slots__`与继承的冲突
子类若未定义`__slots__`，会同时拥有父类`__slots__`和自己的`__dict__`，导致内存优化失效。解决方案：在子类中显式定义`__slots__`。

---

## 八、性能优化建议
1. **大量实例场景**：优先使用`__slots__`（内存节省30%-50%）
2. **属性访问**：`@property`的读操作应避免复杂计算（可缓存结果）
3. **类方法选择**：需访问类状态用`@classmethod`，纯工具方法用`@staticmethod`
4. **字符串表示**：实现`__repr__`提升调试效率，`__str__`提升用户体验

---

## 九、经验总结
面向对象编程的核心是通过类与对象封装状态和行为。掌握`__new__`/`__init__`的生命周期、`__slots__`的内存优化、装饰器的使用场景，以及`__str__`/`__repr__`的输出控制，是编写高效、可维护Python代码的关键。实际开发中应根据具体需求选择合适机制，避免过度设计（如无需内存优化时不必强制使用`__slots__`）。

通过深入理解这些核心机制，开发者能更灵活地应对复杂业务场景（如框架设计、高性能数据处理），并编写出符合Python哲学（“显式优于隐式”“简洁优于复杂”）的优质代码。