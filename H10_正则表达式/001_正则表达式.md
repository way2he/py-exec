# Python正则表达式完全指南

## 目录
1. [基本概念](#1-基本概念)
2. [核心语法](#2-核心语法)
3. [基础示例](#3-基础示例)
4. [进阶用法](#4-进阶用法)
5. [性能优化](#5-性能优化)
6. [最佳实践](#6-最佳实践)
7. [常见陷阱](#7-常见陷阱)
8. [底层原理](#8-底层原理)
9. [实战应用](#9-实战应用)
10. [经验总结](#10-经验总结)
11. [高级实战案例](#11-高级实战案例)
12. [性能优化深入分析](#12-性能优化深入分析)
13. [常见问题深入解决方案](#13-常见问题深入解决方案)
14. [底层原理深入分析](#14-底层原理深入分析)
15. [最佳实践深入建议](#15-最佳实践深入建议)

## 1. 基本概念

### 1.1 什么是正则表达式
正则表达式（Regular Expression，简称regex）是一种用于匹配字符串中字符组合的模式。在Python中，正则表达式通过`re`模块提供支持。

### 1.2 正则表达式的作用
- 文本搜索和替换
- 数据验证
- 字符串解析
- 文本提取
- 格式检查

### 1.3 Python中的正则表达式
Python的`re`模块提供了完整的正则表达式支持，包括：
- 模式匹配
- 字符串替换
- 字符串分割
- 编译优化

## 2. 核心语法

### 2.1 基本元字符
```
.       匹配任意单个字符（除换行符）
^       匹配字符串开头
$       匹配字符串结尾
*       匹配前面的模式0次或多次
+       匹配前面的模式1次或多次
?       匹配前面的模式0次或1次
\       转义字符
|       或运算符
()      分组
[]      字符集
```

### 2.2 预定义字符集
```
\d      匹配任意数字，等价于[0-9]
\D      匹配任意非数字，等价于[^0-9]
\w      匹配字母、数字、下划线，等价于[a-zA-Z0-9_]
\W      匹配非字母、数字、下划线
\s      匹配任意空白字符，包括空格、制表符、换行符
\S      匹配任意非空白字符
```

### 2.3 量词
```
{n}     精确匹配n次
{n,}    匹配n次或更多次
{n,m}   匹配n到m次
*?      非贪婪模式匹配0次或多次
+?      非贪婪模式匹配1次或多次
??      非贪婪模式匹配0次或1次
```

## 3. 基础示例

### 3.1 基本匹配
```python
import re

# 简单匹配
pattern = r"hello"
text = "hello world"
match = re.search(pattern, text)
if match:
    print(f"找到匹配: {match.group()}")  # 输出: 找到匹配: hello

# 使用原始字符串
pattern = r"\d+"  # 匹配一个或多个数字
text = "价格是123元"
match = re.search(pattern, text)
if match:
    print(f"找到数字: {match.group()}")  # 输出: 找到数字: 123
```

### 3.2 常用方法
```python
# re.match() - 从字符串开头匹配
text = "hello world"
match = re.match(r"hello", text)
print(match.group() if match else "未匹配")  # 输出: hello

# re.findall() - 查找所有匹配
text = "价格是123元，数量是456个"
numbers = re.findall(r"\d+", text)
print(numbers)  # 输出: ['123', '456']

# re.sub() - 替换匹配内容
text = "hello world"
new_text = re.sub(r"world", "python", text)
print(new_text)  # 输出: hello python
```

### 3.3 分组和捕获
```python
# 基本分组
text = "姓名: 张三, 年龄: 25"
pattern = r"姓名: (\w+), 年龄: (\d+)"
match = re.search(pattern, text)
if match:
    name = match.group(1)  # 第一个分组
    age = match.group(2)   # 第二个分组
    print(f"姓名: {name}, 年龄: {age}")  # 输出: 姓名: 张三, 年龄: 25

# 命名分组
pattern = r"姓名: (?P<name>\w+), 年龄: (?P<age>\d+)"
match = re.search(pattern, text)
if match:
    print(f"姓名: {match.group('name')}, 年龄: {match.group('age')}")
```

### 3.4 常用修饰符
```python
# re.IGNORECASE (re.I) - 忽略大小写
text = "Hello World"
pattern = r"hello"
match = re.search(pattern, text, re.IGNORECASE)
print(match.group() if match else "未匹配")  # 输出: Hello

# re.MULTILINE (re.M) - 多行模式
text = """第一行
第二行
第三行"""
pattern = r"^第"
matches = re.findall(pattern, text, re.MULTILINE)
print(matches)  # 输出: ['第', '第', '第']

# re.DOTALL (re.S) - 点号匹配所有字符
text = "hello\nworld"
pattern = r"hello.world"
match = re.search(pattern, text, re.DOTALL)
print(match.group() if match else "未匹配")  # 输出: hello\nworld
```

## 4. 进阶用法

### 4.1 零宽断言
```python
# 正向先行断言
text = "价格是123元"
pattern = r"\d+(?=元)"
match = re.search(pattern, text)
print(match.group() if match else "未匹配")  # 输出: 123

# 负向先行断言
text = "价格是123美元"
pattern = r"\d+(?!元)"
match = re.search(pattern, text)
print(match.group() if match else "未匹配")  # 输出: 123

# 正向后行断言
text = "价格是123元"
pattern = r"(?<=价格是)\d+"
match = re.search(pattern, text)
print(match.group() if match else "未匹配")  # 输出: 123

# 负向后行断言
text = "数量是123"
pattern = r"(?<!价格是)\d+"
match = re.search(pattern, text)
print(match.group() if match else "未匹配")  # 输出: 123
```

### 4.2 条件匹配
```python
# 条件匹配示例
text = "123-456-789"
pattern = r"(\d{3})(?:-)?(\d{3})(?:-)?(\d{3})"
match = re.search(pattern, text)
if match:
    print(f"匹配结果: {match.groups()}")  # 输出: 匹配结果: ('123', '456', '789')
```

### 4.3 递归匹配
```python
# 匹配嵌套的括号
text = "((1+2)*(3+4))"
pattern = r"\(([^()]|\([^()]*\))*\)"
match = re.search(pattern, text)
print(match.group() if match else "未匹配")  # 输出: ((1+2)*(3+4))
```

## 5. 性能优化

### 5.1 编译正则表达式
```python
# 未编译版本
text = "hello world"
pattern = r"hello"
match = re.search(pattern, text)

# 编译版本
compiled_pattern = re.compile(pattern)
match = compiled_pattern.search(text)
```

### 5.2 使用非捕获组
```python
# 使用捕获组
pattern = r"(hello) (world)"

# 使用非捕获组
pattern = r"(?:hello) (?:world)"
```

### 5.3 避免回溯
```python
# 可能导致回溯的模式
pattern = r".*x"

# 优化后的模式
pattern = r"[^x]*x"
```

## 6. 最佳实践

### 6.1 编写可维护的正则表达式
```python
# 使用注释模式
pattern = r"""
    \d{3}           # 区号
    -?              # 可选的连字符
    \d{3,4}         # 电话号码
    -?              # 可选的连字符
    \d{4}           # 分机号
"""
phone_pattern = re.compile(pattern, re.VERBOSE)
```

### 6.2 错误处理
```python
def safe_search(pattern, text):
    try:
        return re.search(pattern, text)
    except re.error as e:
        print(f"正则表达式错误: {e}")
        return None
```

### 6.3 测试用例
```python
def test_regex_pattern(pattern, test_cases):
    for test, expected in test_cases:
        result = bool(re.search(pattern, test))
        print(f"测试: {test}")
        print(f"预期: {expected}")
        print(f"实际: {result}")
        print("---")
```

## 7. 常见陷阱

### 7.1 贪婪匹配
```python
# 贪婪匹配
text = "<div>content</div>"
pattern = r"<.*>"
match = re.search(pattern, text)
print(match.group())  # 输出: <div>content</div>

# 非贪婪匹配
pattern = r"<.*?>"
match = re.search(pattern, text)
print(match.group())  # 输出: <div>
```

### 7.2 字符集误解
```python
# 错误的字符集
pattern = r"[a-z]"
# 正确的字符集
pattern = r"[a-zA-Z]"
```

### 7.3 转义问题
```python
# 错误的转义
pattern = "\d"  # 实际匹配 'd'

# 正确的转义
pattern = r"\d"  # 匹配数字
```

## 8. 底层原理

### 8.1 正则表达式引擎
Python的正则表达式引擎使用回溯算法，主要步骤包括：
1. 编译正则表达式
2. 构建状态机
3. 执行匹配
4. 处理回溯

### 8.2 编译过程
```python
# 查看编译后的模式
pattern = r"\d+"
compiled = re.compile(pattern)
print(compiled.pattern)  # 输出: \d+
```

### 8.3 性能分析
```python
import time

def measure_performance(pattern, text, iterations=1000):
    start = time.time()
    for _ in range(iterations):
        re.search(pattern, text)
    end = time.time()
    return end - start
```

## 9. 实战应用

### 9.1 数据提取
```python
# 提取邮箱
text = "联系邮箱: test@example.com"
pattern = r"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"
match = re.search(pattern, text)
print(match.group() if match else "未找到邮箱")

# 提取URL
text = "访问 https://www.example.com 获取更多信息"
pattern = r"https?://[^\s]+"
match = re.search(pattern, text)
print(match.group() if match else "未找到URL")
```

### 9.2 数据验证
```python
# 验证手机号
def validate_phone(phone):
    pattern = r"^1[3-9]\d{9}$"
    return bool(re.match(pattern, phone))

# 验证邮箱
def validate_email(email):
    pattern = r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"
    return bool(re.match(pattern, email))
```

### 9.3 文本处理
```python
# 清理文本
def clean_text(text):
    # 移除多余空白
    text = re.sub(r"\s+", " ", text)
    # 移除特殊字符
    text = re.sub(r"[^\w\s]", "", text)
    return text.strip()

# 格式化文本
def format_text(text):
    # 首字母大写
    text = re.sub(r"^\w", lambda m: m.group().upper(), text)
    # 确保句子以标点结束
    text = re.sub(r"([^.!?])$", r"\1.", text)
    return text
```

## 10. 经验总结

### 10.1 使用建议
1. 优先使用简单模式
2. 适当使用注释
3. 注意性能影响
4. 做好错误处理
5. 编写测试用例

### 10.2 常见问题解决
1. 使用非贪婪匹配避免过度匹配
2. 使用命名分组提高可读性
3. 使用编译模式提高性能
4. 使用原始字符串避免转义问题

### 10.3 进阶技巧
1. 使用零宽断言进行精确匹配
2. 使用条件匹配处理复杂情况
3. 使用递归匹配处理嵌套结构
4. 使用预编译提高性能

## 11. 高级实战案例

### 11.1 日志解析
```python
def parse_log_line(log_line):
    """解析日志行
    
    示例日志格式：
    2024-01-20 10:15:30 [INFO] User login successful - user_id: 12345, ip: 192.168.1.1
    """
    pattern = r"""
        (?P<timestamp>\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2})\s
        \[(?P<level>\w+)\]\s
        (?P<message>.*?)\s
        (?:-\s)?
        (?:user_id:\s(?P<user_id>\d+),\s)?
        (?:ip:\s(?P<ip>\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}))?
    """
    match = re.search(pattern, log_line, re.VERBOSE)
    if match:
        return match.groupdict()
    return None

# 使用示例
log_line = "2024-01-20 10:15:30 [INFO] User login successful - user_id: 12345, ip: 192.168.1.1"
result = parse_log_line(log_line)
print(result)
```

### 11.2 配置文件解析
```python
def parse_config_file(config_text):
    """解析配置文件
    
    示例配置格式：
    [section1]
    key1 = value1
    key2 = value2
    
    [section2]
    key3 = value3
    """
    pattern = r"""
        \[(?P<section>[^\]]+)\]\n
        (?P<content>
            (?:[^\[]+\n)+
        )
    """
    config = {}
    for match in re.finditer(pattern, config_text, re.VERBOSE):
        section = match.group('section')
        content = match.group('content')
        # 解析键值对
        pairs = re.findall(r'(\w+)\s*=\s*([^\n]+)', content)
        config[section] = dict(pairs)
    return config

# 使用示例
config_text = """
[section1]
key1 = value1
key2 = value2

[section2]
key3 = value3
"""
result = parse_config_file(config_text)
print(result)
```

### 11.3 代码分析工具
```python
def analyze_python_code(code):
    """分析Python代码结构"""
    # 查找函数定义
    function_pattern = r"""
        def\s+
        (?P<name>\w+)
        \s*\((?P<args>[^)]*)\)
        \s*(?:->\s*(?P<return_type>[^:]+))?
        \s*:
    """
    
    # 查找类定义
    class_pattern = r"""
        class\s+
        (?P<name>\w+)
        (?:\s*\((?P<inheritance>[^)]*)\))?
        \s*:
    """
    
    functions = []
    classes = []
    
    # 分析函数
    for match in re.finditer(function_pattern, code, re.VERBOSE):
        functions.append({
            'name': match.group('name'),
            'args': match.group('args'),
            'return_type': match.group('return_type')
        })
    
    # 分析类
    for match in re.finditer(class_pattern, code, re.VERBOSE):
        classes.append({
            'name': match.group('name'),
            'inheritance': match.group('inheritance')
        })
    
    return {
        'functions': functions,
        'classes': classes
    }
```

### 11.4 数据清洗工具
```python
class DataCleaner:
    """数据清洗工具类"""
    
    @staticmethod
    def clean_phone_number(phone):
        """清理电话号码格式"""
        # 移除所有非数字字符
        cleaned = re.sub(r'\D', '', phone)
        # 验证格式
        if re.match(r'^1[3-9]\d{9}$', cleaned):
            return cleaned
        return None
    
    @staticmethod
    def clean_email(email):
        """清理邮箱格式"""
        # 转换为小写
        email = email.lower()
        # 移除多余空格
        email = email.strip()
        # 验证格式
        if re.match(r'^[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,}$', email):
            return email
        return None
    
    @staticmethod
    def clean_id_card(id_card):
        """清理身份证号格式"""
        # 转换为大写
        id_card = id_card.upper()
        # 移除空格和连字符
        id_card = re.sub(r'[\s-]', '', id_card)
        # 验证格式
        if re.match(r'^\d{17}[\dX]$', id_card):
            return id_card
        return None
```

## 12. 性能优化深入分析

### 12.1 正则表达式编译优化
```python
class RegexOptimizer:
    """正则表达式优化器"""
    
    def __init__(self):
        self._compiled_patterns = {}
    
    def get_pattern(self, pattern):
        """获取编译后的模式"""
        if pattern not in self._compiled_patterns:
            self._compiled_patterns[pattern] = re.compile(pattern)
        return self._compiled_patterns[pattern]
    
    def search(self, pattern, text):
        """优化的搜索方法"""
        compiled = self.get_pattern(pattern)
        return compiled.search(text)
    
    def findall(self, pattern, text):
        """优化的查找所有方法"""
        compiled = self.get_pattern(pattern)
        return compiled.findall(text)
    
    def sub(self, pattern, repl, text):
        """优化的替换方法"""
        compiled = self.get_pattern(pattern)
        return compiled.sub(repl, text)
```

### 12.2 性能测试与分析
```python
class RegexBenchmark:
    """正则表达式性能测试工具"""
    
    @staticmethod
    def measure_execution_time(func, *args, iterations=1000):
        """测量函数执行时间"""
        import time
        start = time.time()
        for _ in range(iterations):
            func(*args)
        end = time.time()
        return end - start
    
    @staticmethod
    def compare_patterns(patterns, text, iterations=1000):
        """比较多个模式的性能"""
        results = {}
        for name, pattern in patterns.items():
            # 测试编译版本
            compiled = re.compile(pattern)
            compiled_time = RegexBenchmark.measure_execution_time(
                compiled.search, text, iterations=iterations
            )
            
            # 测试未编译版本
            uncompiled_time = RegexBenchmark.measure_execution_time(
                re.search, pattern, text, iterations=iterations
            )
            
            results[name] = {
                'compiled_time': compiled_time,
                'uncompiled_time': uncompiled_time,
                'improvement': (uncompiled_time - compiled_time) / uncompiled_time * 100
            }
        
        return results
```

### 12.3 内存优化
```python
class MemoryOptimizedRegex:
    """内存优化的正则表达式处理"""
    
    def __init__(self):
        self._pattern_cache = {}
        self._max_cache_size = 100
    
    def _clean_cache(self):
        """清理缓存"""
        if len(self._pattern_cache) > self._max_cache_size:
            # 移除最旧的项
            oldest_key = next(iter(self._pattern_cache))
            del self._pattern_cache[oldest_key]
    
    def get_pattern(self, pattern):
        """获取编译后的模式（带缓存）"""
        if pattern not in self._pattern_cache:
            self._clean_cache()
            self._pattern_cache[pattern] = re.compile(pattern)
        return self._pattern_cache[pattern]
```

## 13. 常见问题深入解决方案

### 13.1 回溯问题解决方案
```python
class BacktrackingOptimizer:
    """回溯优化器"""
    
    @staticmethod
    def optimize_pattern(pattern):
        """优化可能导致回溯的模式"""
        # 替换贪婪量词
        pattern = re.sub(r'(\w+)\*', r'\1*?', pattern)
        pattern = re.sub(r'(\w+)\+', r'\1+?', pattern)
        
        # 使用原子组
        pattern = re.sub(r'\(([^)]+)\)', r'(?>\1)', pattern)
        
        return pattern
    
    @staticmethod
    def is_safe_pattern(pattern):
        """检查模式是否安全（不会导致灾难性回溯）"""
        # 检查是否存在嵌套的量词
        if re.search(r'(\w+)[*+?].*\1[*+?]', pattern):
            return False
        
        # 检查是否存在可能导致回溯的交替
        if re.search(r'\|.*\*|\|.*\+|\|.*\?', pattern):
            return False
        
        return True
```

### 13.2 编码问题解决方案
```python
class EncodingHandler:
    """编码处理工具"""
    
    @staticmethod
    def normalize_text(text):
        """标准化文本编码"""
        # 处理Unicode转义
        text = text.encode('unicode_escape').decode()
        text = re.sub(r'\\u([0-9a-fA-F]{4})', lambda m: chr(int(m.group(1), 16)), text)
        
        # 处理特殊字符
        text = re.sub(r'\\[nrt]', lambda m: {
            '\\n': '\n',
            '\\r': '\r',
            '\\t': '\t'
        }[m.group()], text)
        
        return text
    
    @staticmethod
    def handle_chinese(text):
        """处理中文字符"""
        # 提取中文字符
        chinese_pattern = r'[\u4e00-\u9fa5]+'
        chinese_chars = re.findall(chinese_pattern, text)
        
        # 处理中文字符
        processed = []
        for chars in chinese_chars:
            # 这里可以添加特定的处理逻辑
            processed.append(chars)
        
        return processed
```

### 13.3 性能问题解决方案
```python
class PerformanceOptimizer:
    """性能优化工具"""
    
    @staticmethod
    def optimize_large_text(text, chunk_size=1000):
        """分块处理大文本"""
        chunks = []
        for i in range(0, len(text), chunk_size):
            chunk = text[i:i + chunk_size]
            chunks.append(chunk)
        return chunks
    
    @staticmethod
    def parallel_process(pattern, text_chunks):
        """并行处理文本块"""
        import concurrent.futures
        
        def process_chunk(chunk):
            return re.findall(pattern, chunk)
        
        results = []
        with concurrent.futures.ThreadPoolExecutor() as executor:
            futures = [executor.submit(process_chunk, chunk) for chunk in text_chunks]
            for future in concurrent.futures.as_completed(futures):
                results.extend(future.result())
        
        return results
```

## 14. 底层原理深入分析

### 14.1 正则表达式引擎实现
```python
class RegexEngine:
    """简化版正则表达式引擎实现"""
    
    def __init__(self, pattern):
        self.pattern = pattern
        self.states = self._build_states()
    
    def _build_states(self):
        """构建状态机"""
        states = []
        current_state = 0
        
        for char in self.pattern:
            if char == '*':
                # 处理星号
                states.append(('repeat', current_state - 1))
            elif char == '+':
                # 处理加号
                states.append(('repeat_one', current_state - 1))
            elif char == '?':
                # 处理问号
                states.append(('optional', current_state - 1))
            else:
                # 处理普通字符
                states.append(('char', char))
                current_state += 1
        
        return states
    
    def match(self, text):
        """执行匹配"""
        def match_state(state_idx, text_idx):
            if state_idx >= len(self.states):
                return text_idx == len(text)
            
            state = self.states[state_idx]
            if state[0] == 'char':
                if text_idx < len(text) and text[text_idx] == state[1]:
                    return match_state(state_idx + 1, text_idx + 1)
                return False
            elif state[0] == 'repeat':
                # 实现重复匹配逻辑
                pass
            elif state[0] == 'repeat_one':
                # 实现至少一次重复匹配逻辑
                pass
            elif state[0] == 'optional':
                # 实现可选匹配逻辑
                pass
            
            return False
        
        return match_state(0, 0)
```

### 14.2 编译过程分析
```python
class RegexCompiler:
    """正则表达式编译器"""
    
    def __init__(self):
        self.tokens = []
        self.current = 0
    
    def tokenize(self, pattern):
        """将模式转换为标记流"""
        self.tokens = []
        self.current = 0
        
        i = 0
        while i < len(pattern):
            char = pattern[i]
            if char in '*+?':
                self.tokens.append(('quantifier', char))
            elif char in '()[]{}':
                self.tokens.append(('group', char))
            elif char == '\\':
                if i + 1 < len(pattern):
                    self.tokens.append(('escape', pattern[i + 1]))
                    i += 1
            else:
                self.tokens.append(('char', char))
            i += 1
    
    def parse(self):
        """解析标记流"""
        def parse_expression():
            # 实现表达式解析逻辑
            pass
        
        return parse_expression()
```

### 14.3 匹配算法分析
```python
class MatchingAlgorithm:
    """匹配算法分析工具"""
    
    @staticmethod
    def analyze_backtracking(pattern, text):
        """分析回溯情况"""
        steps = []
        
        def match(pattern_idx, text_idx, depth=0):
            if pattern_idx >= len(pattern):
                return text_idx == len(text)
            
            current_char = pattern[pattern_idx]
            if current_char == '*':
                # 分析星号匹配的回溯
                steps.append(f"尝试匹配 '*' 在位置 {text_idx}")
                # 实现回溯分析逻辑
            elif current_char == '+':
                # 分析加号匹配的回溯
                steps.append(f"尝试匹配 '+' 在位置 {text_idx}")
                # 实现回溯分析逻辑
            else:
                # 分析普通字符匹配
                steps.append(f"尝试匹配 '{current_char}' 在位置 {text_idx}")
                # 实现普通匹配分析逻辑
        
        match(0, 0)
        return steps
```

## 15. 最佳实践深入建议

### 15.1 代码组织最佳实践
```python
class RegexPatternManager:
    """正则表达式模式管理器"""
    
    def __init__(self):
        self.patterns = {}
        self.compiled_patterns = {}
    
    def register_pattern(self, name, pattern, description=None):
        """注册模式"""
        self.patterns[name] = {
            'pattern': pattern,
            'description': description,
            'compiled': re.compile(pattern)
        }
    
    def get_pattern(self, name):
        """获取模式"""
        if name not in self.patterns:
            raise KeyError(f"Pattern '{name}' not found")
        return self.patterns[name]
    
    def validate_pattern(self, pattern):
        """验证模式"""
        try:
            re.compile(pattern)
            return True
        except re.error:
            return False
    
    def document_pattern(self, name):
        """生成模式文档"""
        if name not in self.patterns:
            raise KeyError(f"Pattern '{name}' not found")
        
        pattern_info = self.patterns[name]
        return f"""
        模式名称: {name}
        正则表达式: {pattern_info['pattern']}
        描述: {pattern_info['description']}
        示例:
        {self._generate_examples(pattern_info['pattern'])}
        """
    
    def _generate_examples(self, pattern):
        """生成示例"""
        # 实现示例生成逻辑
        pass
```

### 15.2 测试最佳实践
```python
class RegexTester:
    """正则表达式测试工具"""
    
    def __init__(self):
        self.test_cases = []
    
    def add_test_case(self, pattern, text, expected, description=None):
        """添加测试用例"""
        self.test_cases.append({
            'pattern': pattern,
            'text': text,
            'expected': expected,
            'description': description
        })
    
    def run_tests(self):
        """运行测试"""
        results = []
        for test in self.test_cases:
            try:
                match = re.search(test['pattern'], test['text'])
                actual = match.group() if match else None
                passed = actual == test['expected']
                results.append({
                    'description': test['description'],
                    'passed': passed,
                    'expected': test['expected'],
                    'actual': actual
                })
            except re.error as e:
                results.append({
                    'description': test['description'],
                    'passed': False,
                    'error': str(e)
                })
        return results
    
    def generate_report(self):
        """生成测试报告"""
        results = self.run_tests()
        report = []
        for result in results:
            if result.get('error'):
                report.append(f"错误: {result['description']} - {result['error']}")
            else:
                status = "通过" if result['passed'] else "失败"
                report.append(f"{status}: {result['description']}")
                if not result['passed']:
                    report.append(f"  预期: {result['expected']}")
                    report.append(f"  实际: {result['actual']}")
        return "\n".join(report)
```

### 15.3 性能优化最佳实践
```python
class RegexOptimizer:
    """正则表达式优化器"""
    
    @staticmethod
    def optimize_pattern(pattern):
        """优化模式"""
        # 移除不必要的捕获组
        pattern = re.sub(r'\(\?:([^)]+)\)', r'\1', pattern)
        
        # 优化字符集
        pattern = re.sub(r'[a-zA-Z]', lambda m: m.group().lower(), pattern)
        
        # 优化量词
        pattern = re.sub(r'(\w+)\*', r'\1*?', pattern)
        
        return pattern
    
    @staticmethod
    def analyze_performance(pattern, text):
        """分析性能"""
        import time
        import cProfile
        
        def profile_match():
            re.search(pattern, text)
        
        profiler = cProfile.Profile()
        profiler.enable()
        profile_match()
        profiler.disable()
        
        return profiler.getstats()
    
    @staticmethod
    def suggest_optimizations(pattern):
        """建议优化方案"""
        suggestions = []
        
        # 检查是否存在可能导致回溯的模式
        if re.search(r'(\w+)[*+?].*\1[*+?]', pattern):
            suggestions.append("警告: 检测到可能导致回溯的模式")
        
        # 检查是否存在未使用的捕获组
        if re.search(r'\([^?][^)]*\)(?!\d)', pattern):
            suggestions.append("建议: 使用非捕获组 (?:...) 替代未使用的捕获组")
        
        # 检查是否存在可以优化的字符集
        if re.search(r'[a-zA-Z]', pattern):
            suggestions.append("建议: 考虑使用不区分大小写的模式")
        
        return suggestions
```