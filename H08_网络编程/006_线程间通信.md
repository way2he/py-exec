# Python线程间通信完全指南

## 一、基本概念
线程间通信（Inter-Thread Communication, ITC）是多线程编程中协调不同线程执行逻辑的核心机制。由于Python全局解释器锁（GIL）的存在，虽然CPU密集型任务无法通过多线程实现真正并行，但I/O密集型任务仍需通过线程协作完成数据交换。

### 1.1 核心术语
- **共享内存**：多个线程访问同一块内存区域（需配合同步机制）
- **消息传递**：通过中间媒介（如队列）传递数据（天然线程安全）
- **同步原语**：锁（Lock）、事件（Event）、条件变量（Condition）等控制线程执行顺序

## 二、常用通信机制与示例代码
### 2.1 队列（queue.Queue）
Python标准库`queue`提供的线程安全队列是最常用的通信方式，底层通过`threading.Lock`实现原子操作。

```python
import threading
import queue

# 定义共享队列（最大容量3）
shared_queue = queue.Queue(maxsize=3)

class Producer(threading.Thread):
    def run(self):
        for i in range(5):
            shared_queue.put(f"item-{i}")  # 放入数据（满时阻塞）
            print(f"生产者{self.name} 放入: item-{i}")

class Consumer(threading.Thread):
    def run(self):
        for _ in range(5):
            item = shared_queue.get()  # 取出数据（空时阻塞）
            print(f"消费者{self.name} 取出: {item}")
            shared_queue.task_done()  # 标记任务完成

if __name__ == "__main__":
    producers = [Producer() for _ in range(2)]
    consumers = [Consumer() for _ in range(2)]

    for p in producers: p.start()
    for c in consumers: c.start()

    for p in producers: p.join()
    shared_queue.join()  # 等待所有任务完成
    for c in consumers: c.join()
```

### 2.2 事件（threading.Event）
通过`Event`对象的`set()`和`wait()`方法实现线程间的信号传递。

```python
import threading
import time

# 初始化事件（默认未设置）
ready_event = threading.Event()

def waiter():
    print("等待事件触发...")
    ready_event.wait()  # 阻塞直到事件被设置
    print("事件已触发！")

def setter():
    time.sleep(2)
    ready_event.set()  # 设置事件

threading.Thread(target=waiter).start()
threading.Thread(target=setter).start()
```

## 三、适用场景分析
| 机制       | 典型场景                     | 优点                 | 缺点                 |
|------------|------------------------------|----------------------|----------------------|
| queue.Queue| 生产者-消费者模型            | 线程安全、自动阻塞   | 需处理队列满/空状态  |
| Event      | 启动/停止信号传递            | 轻量级、无数据传输   | 仅能传递布尔状态     |
| Condition  | 复杂条件触发（如库存预警）   | 支持条件谓词检查     | 需配合Lock使用       |

## 四、底层原理剖析（以queue.Queue为例）
查看`queue.py`源码（Python 3.10），核心同步逻辑通过`threading.Lock`和`threading.Condition`实现：

```python
# 节选queue.Queue部分源码
class Queue:
    def __init__(self, maxsize=0):
        self.maxsize = maxsize
        self._init(maxsize)
        # 创建锁和条件变量
        self.mutex = threading.Lock()
        self.not_empty = threading.Condition(self.mutex)
        self.not_full = threading.Condition(self.mutex)

    def put(self, item, block=True, timeout=None):
        with self.not_full:
            # 检查队列是否已满
            if self._qsize() >= self.maxsize:
                if not block:
                    raise Full
                self.not_full.wait(timeout=timeout)
            # 实际入队操作
            self._put(item)
            self.not_empty.notify()  # 唤醒等待取数据的线程
```

`put()`方法通过`with self.not_full`获取条件变量锁，当队列满时调用`wait()`释放锁并阻塞；数据入队后调用`notify()`唤醒等待的消费者线程。

## 五、最佳实践
1. **限制队列容量**：避免内存溢出（通过`maxsize`参数设置）
2. **使用守护线程**：消费者线程设置`daemon=True`，主程序退出时自动终止
3. **优先选择标准库**：`queue`模块经过严格测试，比自定义锁更可靠
4. **避免全局变量**：通过参数传递队列对象而非直接访问全局作用域

## 六、常见陷阱与规避
### 6.1 死锁陷阱
**场景**：线程A持有锁L1等待锁L2，线程B持有锁L2等待锁L1
**规避**：
- 按固定顺序获取锁
- 使用`threading.RLock`可重入锁
- 设置锁获取超时（`lock.acquire(timeout=5)`）

### 6.2 队列泄漏
**场景**：未调用`task_done()`导致`queue.join()`永久阻塞
**规避**：每个`get()`后必须调用`task_done()`，或使用`Queue.task_done()`的上下文管理器

## 七、性能优化建议
1. **减少锁竞争**：将大任务拆分为多个小任务，缩短锁持有时间
2. **使用无锁队列**：对性能要求极高时可考虑`concurrent.futures`的线程池（底层基于无锁队列实现）
3. **批量操作**：合并多次`put()`为一次批量`put_nowait()`（需确保线程安全）

## 八、经验总结
线程间通信的核心是平衡安全性与效率：
- 简单数据传递优先用`queue.Queue`（自带背压机制）
- 状态通知用`Event`（最小化资源消耗）
- 复杂条件同步用`Condition`（配合谓词检查）
- 永远为共享数据访问添加同步机制（避免竞态条件）
